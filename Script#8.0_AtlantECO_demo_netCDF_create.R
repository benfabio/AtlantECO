
### 15/02/2022: Demo R script to convert a (theoretical) gridded data.frame into a spatial array to be then converted into a netCDF (.nc)
### All credits to: https://pjbartlein.github.io/REarthSysSci/netCDF.html#create-and-write-a-netcdf-file (section 4: Data frame-to-array conversion(rectangular to raster)

# NetCDF is a widely used format for exchanging or distributing climate data, and has also been adopted in other fields, particularly in bioinformatics, and in other disciplines where large multidimensional arrays of data are generated. NetCDF files are self-describing, in the sense that they contain metadata that describes what is contained in a file, such as the latitude and longitude layout of the grid, the names and units of variables in the data set, and “attributes” that describe things like missing value codes, or offsets and scale factors that may have been used to compress the data. NetCDF files are also machine-independent because can be transferred among servers and computers that are running different operating systems, without having to convert the files in some way. Originally developed for storing and distributing climate data, such as those generated by climate simulation or reanalysis models, the format and protocols can be used for other gridded data sets. NetCDF libraries are developed and maintained by Unidata http://www.unidata.ucar.edu/software/netcdf/ and easy-to-use applications for producing simple visualizations of NetCDF files exist, such as Panoply, http://www.giss.nasa.gov/tools/panoply/.

# There are two versions of netCDF; netCDF3, which is widely used, but has some size and performance limitations, and netCDF4, which supports larger data sets and includes additional capabilities like file compression.

# R has the capability of reading and writing (and hence analyzing) netCDF files, using the ncdf and ncdf4 packages provided by David Pierce, and through other packages like raster, metR1, and RNetCDF. The ncdf4.helpers and easyNCDF packages provide some additional tools.

# The ncdf4 package is available on both Windows and Mac OS X (and Linux), and supports both the older NetCDF3 format as well as netCDF4. (See the ncdf/ncdf4 web page at http://cirrus.ucsd.edu/~pierce/ncdf/index.html for further discussion.)


### To install and load libraries
# install.packages("ncdf4")
library("ncdf4")
library("raster")
library("tidyverse")

### Dummy theoretical data.frame to be converted into a .nc
ddf <- data.frame(lon = sample(x = seq(from=-179.5,to=179.5,by=1), replace = T, size = 10000),
        lat = sample(x = seq(from=-89.5,to=89.5,by=1), replace = T, size = 10000),
        depth = sample(x = seq(from=0,to=3000,by=10), replace = T, size = 10000),
        month = sample(x = seq(from=1,to=12,by=1), replace = T, size = 10000), 
        value = runif(n = 10000, min = 0, max = 100) ) # eo ddf
#
summary(ddf)

# ddf # quick plot
ggplot(aes(x = lon, y = lat, fill = value), data = ddf) + geom_point(colour = "black", pch = 21) + scale_fill_distiller(palette = "Spectral") + theme_void()

### 1°) Convert a R data frame to an array
# In this first example, a “full” data frame (e.g. one with nlon x nlat rows, and nt columns) is reshaped into a 3-D nlon`* by nlat by nt array. (The example also illustrates the conversion of a nlon x nlat rows by 1-column variable in a data frame into a 2-D nlon by nlat array.)

# 1.1) Initial set up – create dimension variables
lon <- ddf$lon
lat <- ddf$lat
time <- ddf$month
tunits <- 'month'
depths <- ddf$depth
zunits <- 'meters'

### Define the 4D grid (x,y,z,time) of your array/netCDF --> the standard grid on whih to put your obs ('value') on
# nlon <- seq(from = -179.5, to = 179.5, by=1) # longitudinal grid
# nlat <- seq(from = -89.5, to = 89.5, by=1) # latitudinal grid
# ntime <- c(1:12) # months
# ndepth <- seq(from = 0, to = 5500, by=10) # depths

### Note: Those can also be copied from a model netCDF (e.g., World Ocean Atlas) that you can use as a standard
### For instance, upload the stabdard WOA grid through one of their basic .nc files like below: 
ncin <- nc_open("woa13_all_o_monthly.nc")
print(ncin) # to check what's inside
# Has lat, lon, depth, time. Extract those
# Longitude
lon <- ncvar_get(ncin,"lon")
nlon <- dim(lon)
# unique(lon)
# Latitude
lat <- ncvar_get(ncin,"lat")
nlat <- dim(lat)
# unique(lat)
# print(c(nlon,nlat)) # good
# Time/months
time <- ncvar_get(ncin,"time")
time
tunits <- ncatt_get(ncin,"time","units")
nt <- dim(time)
nt
# Depth layers
depth <- ncvar_get(ncin,"depth")
ndepth <- dim(depth)
ndepth

# Create EMPTY arrays of dimensions nlon * nlat * nt array
fillvalue <- NA
#tmp_array <- array(fillvalue, dim = c(nlon, nlat, nt, ndepth) ) # str(tmp_array) ; head(tmp_array)
# nlon * nlat arrays for vector of 'value'
val_array <- array(NA, dim = c(nlon, nlat, nt, ndepth) ) # summary(val_array)
# dim(val_array)
# val_array[23,57,,12]

### 1.2) 2 possible approaches for filling the array: 
# - Explicit copying from a data frame to array (for loop)
# - Partial loop avoidance

# In the first, most explict, approach, we loop over the rows in the data frame, find the 'j' and 'k' column and row that each observation falls in (using which.min()), and then copy the values for each row into the arrays. This takes a relatively long time for data sets with hundreds of rows and columns. It is the most explicit fashion, but takes a VERY LONG TIME, and we don't like that...

# nobs <- nrow(ddf) # ; nobs
# # i <- 49 # For testing stuff below
# for(i in 1:nobs) {
#
#    message(paste(i, sep = ""))
#    # figure out location in the target array of the values in each row of the data frame
#    j <- which.min( abs(nlon - ddf$lon[i]) )
#    k <- which.min( abs(nlat - ddf$lat[i]) )
#    l <- which.min( abs(ntime - ddf$month[i]) )
#    m <- which.min( abs(ndepth - ddf$depth[i]) )
#    # copy data from ddf to array
#    # tmp_array[j,k,1:ntime] <- as.matrix( ddf[i,3:(ntime+2)] )
#    val_array[j,k,l,m] <- ddf$value[i]
#
# } # eo for loop - i in nobs
# # # Check
# summary(val_array)

# In the second (better) approach: use a sapply() to incremently apply a function to create vectors of indices (j2, k2, l2, m2) that describe which columns and rows of the array each row of the data frame is assigned to. For example, the function function(x) which.min(abs(lon-x)) finds the closest longitude of the full array (lon3) to the longitude of each row of the data frame (tmp_df03$lon, the x argument of the function).
# basically, you're getting the index of the closest value in 'ddf'
j2 <- sapply(ddf$lon, function(x) which.min(abs(lon - x)) ) 
k2 <- sapply(ddf$lat, function(x) which.min(abs(lat - x)) ) 
l2 <- sapply(ddf$month, function(x) which.min(abs(time - x)) ) 
m2 <- sapply(ddf$depth, function(x) which.min(abs(depth - x)) ) 

# To check: head(val_array[cbind(j2,k2,l2,m2)])
val_array[cbind(j2,k2,l2,m2)] <- as.matrix(ddf$value) 
summary(val_array) # Nice, seems to have worked.


### 3°) Create and write a netCDF file from 'val_array'
# In this example, the arrays created above are written out using the ncdf4 package. Creating and writing (new) netCDF files involves first defining or “laying out” the dimensions and coordiate variables and the individual variables, and the attrributes of each, and then creating the file and “putting” the data into the file, along with additional attributes or metadata.

# path and file name, set dname
ncpath <- getwd() # current working directory - feel free to modify this as you will
ncname <- "demo_ncdf4"  
ncfname <- paste(ncpath,"/", ncname, ".nc", sep = "")
dname <- "val"  
# Then define the contents of the file:
londim <- ncdim_def("lon", "degrees_east", as.double(lon) ) 
latdim <- ncdim_def("lat", "degrees_north", as.double(lat) ) 
timedim <- ncdim_def("time", "month", as.double(time) )
depthdim <- ncdim_def("depth", "meters", as.double(depth) )

### Note: You might have additional dimensions in mind (or want ot modify the deph and time dimensions). Modify the script above and below accordingly.

# Define the variable(s)
fillvalue <- NA
varname <- "Dummy variable" # Name of the variable whose values are stored in 'ddf$value'
var_def <- ncvar_def("value","unit", list(londim,latdim,timedim,depthdim), fillvalue, varname, prec = "float")
# Define as many variables as you want here

# Next, create the actual .nc file, and put the variables into it, along with additional variable and “global” attributes (those that apply to the whole file). Note that the attributes are of key importance to the self-documenting properties of netCDF files.

ncout <- nc_create(ncfname, list(var_def), force_v4 = T) # add variables in the 'list()'


# Put variables
ncvar_put(ncout,var_def,val_array)

# put additional attributes into dimension and data variables
# ?ncatt_put
ncatt_put(ncout,"lon","axis","decimalLongitude", verbose = T) 
ncatt_put(ncout,"lat","axis","decimalLatitude")
ncatt_put(ncout,"time","axis","Months")
ncatt_put(ncout,"depth","axis","Depth")

# add global attributes
ncatt_put(ncout, varid = 0, attname = "Dataset", attval = "AtlantECO Dataset #XXX") # if varid==0, then a global attribute is written instead of a variable's attribute
ncatt_put(ncout, varid = 0,"Institution", "ETH Zürich, D-USYS, IBP, UP group")
ncatt_put(ncout, varid = 0,"Description", "Dummy dataset")
ncatt_put(ncout, varid = 0,"Reference", "doi:xx.xxxx/xxxx-xxxxx-xx-xx-x")
history <- paste("Fabio Benedetti (fabio.benedetti@usys.ethz.ch); last update: ", date(), sep = ", ")
ncatt_put(ncout, varid = 0, "Funding statement","This project has received funding from the European Union’s Horizon 2020 research and innovation programme under grant agreement no. 862923. This output reflects only the author’s view, and the European Union cannot be held responsible for any use that may be made of the information contained therein.")
# Feel free to add as many as you want

# Get a summary of the created file:
print(ncout)

# values2 <- ncvar_get(ncout,"value")
# summary(values2)

### BONUS: How to extract the values from the netCDF into a 'raster'
# ?raster::stack
ras <- raster::stack(x = ncfname)
#ras # names = depth layers names(ras)
names(ras) <- paste(depth,"m", sep = "")
plot(ras)
summary(ras)

####################################################################################################################################################################################################################################################################################
